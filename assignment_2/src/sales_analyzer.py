"""
Sales Analyzer

Performs functional programming style analytical queries over sales data using
streaming operations, data aggregation, and lambda expressions
"""

import csv
from decimal import Decimal, ROUND_HALF_UP
from functools import reduce
from itertools import groupby
from operator import add, attrgetter
from typing import List, Dict, Iterable

from sales_record import SalesRecord

class SalesAnalyzer:
  """
  Performs functional programming style analytical queries over sales data
  Uses stream operations, data aggregation, and lambda expressions
  """
  def __init__(self, file_path: str) -> None:
      """Load and parse the CSV file into list of SalesRecord objects"""
      self.records: List[SalesRecord] = self.load_csv(file_path)

  def load_csv(self, file_path: str) -> List[SalesRecord]:
    """
    Read the CSV, and convert each row into a SalesRecord list

    Args:
      file_path (str): Path to CSV file

    Returns:
      List[SalesRecord]: Parsed rows of CSV file into SalesRecord objects
    """
    with open(file_path, "r") as file:
      reader = csv.DictReader(file)

      # create objects of SalesRecord
      return [SalesRecord(**row) for row in reader]

  def total_revenue(self) -> Decimal:
    """
    Compute total revenue generated by the sales data

    Returns:
      Decimal: Sum of (price * quantity) for all records
    """
    return reduce(add, (r.price * r.quantity for r in self.records), 0)

  def total_quantity(self) -> int:
    """
    Compute total quantity of items sold

    Returns:
      int: Sum of quantity for all records
    """
    return reduce(add, (r.quantity for r in self.records), 0)

  def mean_order_value(self) -> Decimal:
    """
    Compute the mean revenue per item sold

    Returns:
      Decimal: Mean order value
    """
    mean = self.total_revenue() / self.total_quantity()
    return mean.quantize(Decimal("0.01"), ROUND_HALF_UP)

  def highest_revenue_sale(self) -> SalesRecord:
    """
    Compute the order that generated the highest revenue

    Returns:
      SalesRecord: Record with maximum (price * quantity) value
    """
    return max(self.records, key = lambda r: r.price * r.quantity)

  def orders_above_threshold(self, amount: Decimal) -> Iterable[SalesRecord]:
    """
    Yield all SalesRecord orders whose revenue exceeds a certain threshold

    Returns:
      Iterable[SalesRecord]: Lazy iterator of orders above a certain revenue threshold
    """
    return filter(lambda r: r.price * r.quantity > amount, self.records)

  def revenue_for_region(self, region: str) -> Decimal:
    """
    Compute revenue generated by a specific region

    Args:
      region (str): Region to filter

    Returns:
      Decimal: Total revenue of a particular region
    """
    return reduce(add,
      map(lambda r: r.price * r.quantity,
        filter(lambda r: r.region == region, self.records)
      ),
      0
    )

  def total_revenue_by_region(self) -> Dict[str, Decimal]:
    """
    Compute total revenue generated by each region

    Returns:
      Dict[str, Decimal]: Keys are region names. Values are revenue totals
    """
    # grouping requires records to be sorted
    sorted_records = sorted(self.records, key = attrgetter("region"))

    return {
      # accumulate revenue for the current region
      region : reduce(add, (r.price * r.quantity for r in group_iter), 0)
        for region, group_iter in groupby(sorted_records, key = attrgetter("region"))
    }
